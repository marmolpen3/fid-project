---
title: "R Notebook"
output: html_notebook
---

# Bike Rental Data

Los sistemas de alquiler de bicicletas suelen recopilar información interesante como la duración, los puntos de salida y destino y el tiempo del viaje. Con el fin de mejorar la gestión, se propone anticipar la demanda que habrá en un determinado rango de tiempo. Teniendo en cuenta la franja horaria, el tipo de día (laborable o festivo), la climatología, etc.

Por lo tanto, el objetivo es predecir la demanda de bicicletas en una serie de franjas horarias, empleando el siguiente conjunto de [datos](https://www.kaggle.com/datasets/aguado/bike-rental-data-set-uci).

El resto del documento se organiza de la siguiente forma: en la sección 1 se realiza un estudio de los datos y su prepocesamiento.

## Preprocesamiento y análisis de los datos

Instalación de ***tidyverse*** para la manipulación de los datos y la visualización.

```{r}
library(tidyverse)
```

Carga del dataset: subconjuto de entrenamiento. Estudio de los datos tal y como se obtienen de ***Kaggle***. Como veremos los datos están todos en una columna separados por ";".

```{r}
bikes <- read.csv("data/train.csv")
head(bikes)
colnames(bikes)
dim(bikes)
```

#### Análisis de los datos

En primer lugar, separamos los datos por ";" con el fin de tener las columnas separadas y poder análizar correctamente los datos. La función *summary* nos ofrece un resumen por cada una de las variables presentes en el dataset.

```{r}
bikes <- read.table("data/train.csv", na.strings="", header=TRUE, sep=";", dec=".")
names(bikes)[12] <- "num_bikes"
head(bikes)
colnames(bikes)
dim(bikes)
summary(bikes)
```

Comprobamos la homogeneidad de los datos:

¿Cuál ha sido el registro de datos recopilados según la hora? ¿Cuál ha sido el registro de datos recopilados según la temporada del año?

```{r}
bikes %>%
  group_by(hour) %>% 
  count()
bikes %>%
  group_by(season) %>% 
  count()
```

¿Cuántas bicicletas se han alquilado según la hora del día? ¿Cuántas bicicletas se han alquilado según la temporada del año?

```{r}
  bikes %>%
  group_by(hour) %>%
  summarize(total_bikes = sum(num_bikes))
  bikes %>%
  group_by(season) %>%
  summarize(total_bikes = sum(num_bikes))
```

Porcentaje de bicicletas alquiladas según la hora del día.

```{r}
```

Búsqueda de relación lineal: dibujar el número de bicicletas en función del resto de variables.

```{r}
```

#### Preprocesado de los datos

Tras estudiar las variables presentes en el conjunto de datos procedemos a la limpieza de los datos. El objetivo es encontrar valores perdidos (NA) y filas duplicadas.

```{r}
# Preprocesamiento 1. Valores perdidos y Filas duplicadas

# Búsqueda de valores NA
bikes <- bikes %>%
  filter(complete.cases(bikes))
```

```{r}
# Preprocesamiento 2. Detección y eliminación de outliers
str(bikes)
head(bikes)
```

```{r}
# Outliers: hour
boxplot(bikes$hour, horizontal = TRUE)
boxplot.stats(bikes$hour)
```

```{r}
# Outliers: season
boxplot(bikes$season, horizontal = TRUE)
boxplot.stats(bikes$season)
```

```{r}
# Outliers: weather
boxplot(bikes$weather, horizontal = TRUE)
boxplot.stats(bikes$weather)
```

```{r}
# Outliers: temp
boxplot(bikes$temp, horizontal = TRUE)
boxplot.stats(bikes$temp)
```

```{r}
# Outliers: atemp
boxplot(bikes$atemp, horizontal = TRUE)
boxplot.stats(bikes$atemp)
```

```{r}
# Outliers: humidity
boxplot(bikes$humidity, horizontal = TRUE)
boxplot.stats(bikes$humidity)
```

```{r}
# Outliers: windspeed
boxplot(bikes$windspeed, horizontal = TRUE)
boxplot.stats(bikes$windspeed)
```

La velocidad del viento (windspeed) es el único atributo que presenta outliers, por lo que se procede a eliminarlos.

```{r}
# Outliers en windspeed por encima de 32 km/h
outlier_min <- min(boxplot.stats(bikes$windspeed)$out)

bikes_without_liers <- bikes$windspeed[bikes$windspeed < outlier_min]

# Comprobación
boxplot(bikes_without_liers, horizontal = TRUE)
boxplot.stats(bikes_without_liers)

# Filtrado de dataframe
bikes_train_set <- filter(bikes, bikes$windspeed < outlier_min)

str(bikes_train_set)
head(bikes_train_set)
```

Dataframe preprocesado para identificación de valores perdidos, ejemplos duplicados y detección y eliminación de outliers.

```{r}
summary(bikes_train_set)
```

## Visualización

Instalación de ggplot2

```{r}
library(ggplot2)
```

```{r}
# So, now...what do we looking for?
```

```{r}
bikes_by_hour <- bikes_train_set %>%
  group_by(hour) %>%
  summarise(total_bikes = sum(num_bikes))

ggplot(bikes_by_hour, aes(x = hour, y = total_bikes)) +
  geom_bar(stat = "identity")
```

## Algoritmo lm()

Modelo realizado con lm como en la práctica 3 (regresión).

Y predicción con ese modelo.

## Algoritmos Caret

En este punto, vamos a generar distintos modelos con varios métodos que incluye el paquete Caret. A partir de estos modelos, los cuales son creados a partir del subconjunto de entrenamiento, se procederá a la predicción del número de bicicletas alquiladas para cada uno de los ejemplos del subconjunto de prueba.

Antes de comenzar, se carga el paquete Caret.

```{r}
library(caret)
```

A continuación, creamos la función de control mediante `trainControl`. Con esta función vamos a controlar cómo se crearán los modelos.

```{r}
fitControl <- trainControl(
  method = "cv",
  number = 10,
  #summaryFunction = twoClassSummary,
  #classProbs = TRUE,
  savePredictions = TRUE,
  verbose = FALSE
)
```

Con esto, tomaremos el subconjunto de entrenamiento, el cual se usará para preparar los distintos modelos generados con el paquete Caret.

```{r}
# Aquí se debe cargar el data frame ya limpio preprocesado,
# listo para usarlo como conjunto de entrenamiento.
# Ya tendría que estar cargado en memoria por los pasos previos.
bikes_train_set <- bikes_train_set %>%
  select(-id)
```

Acto seguido, se procede a crear un primer modelo de regresión.

```{r}
model_rf_reg <- train(num_bikes ~ .,
                      bikes_train_set,
                      method = "rf",
                      ntree = 5)

model_rf_reg
```

```{r}
model_xgbTree <- train(
  num_bikes ~ .,
  bikes_train_set,
  method = "xgbTree",
  trControl = fitControl)

model_xgbTree
```

Hacemos predicción:

```{r}
testing <- read_csv2("data/test.csv")
head(testing)
predict(model_rf_reg, newdata = head(testing))
predict(model_xgbTree, newdata = head(testing))
```

## Comparativa de modelos
